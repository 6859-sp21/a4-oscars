<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.13.0/d3-legend.js"></script>
  <script src="https://cdn.rawgit.com/RasmusFonseca/d3RangeSlider/master/d3RangeSlider.js"></script>
  <link href='https://fonts.googleapis.com/css?family=Didact Gothic' rel='stylesheet'>
  <link href="https://cdn.rawgit.com/RasmusFonseca/d3RangeSlider/master/d3RangeSlider.css" rel="stylesheet">

  <style type="text/css">
    h1 { 
      color: 	#b8a22a; 
      font-family: 'Didact Gothic', sans-serif; 
      font-size: 60px;
      line-height: 1; 
      margin-left: 40px;
      margin-top: 20px;
      margin-bottom: 0px;
      text-align: left; 
    }

    h2 {
      color: 	#b8a22a; 
      font-family: 'Didact Gothic', sans-serif;
      line-height: 1; 
      margin-top: 5px;
      margin-left: 40px;
      text-align: left; 
    }
    body {
      background-color: rgb(29, 28, 28);
    }

    g.cell {
      background-color: blue;
    }

    #main {
      display: flex;
    }

    #slider-section {
      width: 50%;
      margin: auto;
      padding-top: 30px;
    }

    #slider-container {
      position: relative;
      height:30px;
      background-color: #eeeef5;
    }

    #range-label {
      color: white;
      text-align: center;
      font-family: 'Didact Gothic', sans-serif;
      font-size: 30px;
    }

    #legend {
      /* z-index for now so that the tooltips work on the graph. need to fix this later. */
      z-index: -100; 
    }

  </style>
</head>
<body>
  <div id="header" style="display: flex; flex-direction: row; align-items: center; margin-left: 50px;">
    <img src="./oscars_icon.png" width="100" height="130">
    <div style="display: flex; flex-direction: column;">
      <h1 id="title">OSCARS</h1>
      <h2>winners & nominees by race</h2>
    </div>
  </div>

  <div id="slider-section">
    <div id="range-label">1927 - 2019</div>
    <div id="slider-container"></div>
  </div>
  <div id="main">
    <div id="graph"></div>
    <div id="legend"></div>
  </div>

  <div id="footer">
    Adapted from: https://www.d3-graph-gallery.com/graph/circularpacking_basic.html, 4/3/2021
  </div>

  <!-- JAVASCRIPT -->
  <script>
    var svgWidth = 1500
    var svgHeight = 1000
    var width = 1000
    var height = 1000
    var graphsvg = d3.select("#graph")
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        .attr("transform", "translate(400, 0)"); // pushes viz to right + up


    var legendsvg = d3.select("#legend")
      .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        .attr("transform", "translate(-1100, 0)"); // pushes viz to right + up
    legendsvg.append("g");

    var tooltip = d3.select("#main")
      .append("div")
      .style("position", "absolute")
      .style("visibility", "hidden")
      .style("background-color", "black")
      .style("color", "white")
    
    function update(data, allData) {      
      var numDataPoints = data.length;
      var nomineeData = data.filter(d => d.winner === "FALSE");
      var numNominees = nomineeData.length;
      
      var winnerData = data.filter(d => d.winner === "TRUE");
      var numWinners = winnerData.length;
      
      let numNomineesSeen = 0;
      let numWinnersSeen = 0;
      // we position the nominees in a 1 layer ring, and the physics
      // simulation will take care of repelling the overlaps
      let nomineeRadius = Math.max(Math.sqrt(numWinners*280), 120)
      let winnerRadius = Math.max(numWinners * 0.5, 45)
      for (let i = 0; i < numDataPoints; i++) {
        // if we're looking at a nominee
        if (data[i].winner === "FALSE") {
          // calculate angle of the dot
          var theta = numNomineesSeen * 2 * Math.PI / numNominees
          // calculate coordinates relative to center of canvas
          data[i].x = nomineeRadius * Math.cos(theta) + width / 2;
          data[i].y = nomineeRadius * Math.sin(theta) + height / 2;
          data[i].level = "Nominee"
          numNomineesSeen += 1;
        }
        else {
          var theta = numWinnersSeen * 2 * Math.PI / numWinners
          data[i].x = winnerRadius * Math.cos(theta) + width / 2;
          data[i].y = winnerRadius * Math.sin(theta) + height / 2;
          data[i].level = "Winner"
          numWinnersSeen += 1
        }
      }

      // default color scale
      // color = d3.scaleOrdinal(d3.schemeCategory10).domain(data.map(d => d.fixed_race));
      // customized color scale
      color = d3.scaleOrdinal()
        .domain(['white', 'black', 'hispanic', 'asian', 'other'])
        .range(['#615516', '#b8a22a', '#CE5E33', '#1F848B', '#9C29B1'])
      var node = graphsvg.selectAll(".graph-circle").data(data, d => d.id)

      node.exit().remove();
      
      node
        .enter()
        .append("circle")
          .classed("graph-circle", true)
          .attr("r", 2)
          .attr("cx", width / 2)
          .attr("cy", height / 2)
          .style("fill", d => color(d.fixed_race))
          .style("fill-opacity", 1)
          .attr("stroke", d => color(d.fixed_race))
          .style("stroke-width", 4)
          .on("mouseover", function(){
              tooltip
              .style("visibility", "visible")
              })
          .on("mousemove", function(d){
              tooltip
              .style("top", (d3.event.pageY + 5) + "px")
              .style("left", (d3.event.pageX + 5) + "px")
              .html(d.level + "<br>" + "Name: " + d.name + "<br>Film: " + d.film + "<br>Award: " + d.category + "<br>Race: " + d.fixed_race + "<br>Year:" + d.year_ceremony)
              })
          .on("mouseout", function(){
              tooltip
              .style("visibility", "hidden")
              })
    }

    d3.csv("oscar_nominees_with_fixed_race.csv", function(csv_data) {
      var store = csv_data // stores the current filtered data according to year range

      function getData(startYear, endYear) {
        var data = []
        for (var i = 0; i < csv_data.length; i++) {
          // push all datapoints, both nominees and winners
          var year = csv_data[i].year_ceremony;
          if (year >= startYear && year <= endYear) {
            data.push(csv_data[i]);
          }
        }
        return data;
      }

      // default color scale
      // color = d3.scaleOrdinal(d3.schemeCategory10).domain(data.map(d => d.fixed_race));
      // customized color scale
      color = d3.scaleOrdinal()
        .domain(['white', 'black', 'hispanic', 'asian', 'other'])
        .range(['#615516', '#b8a22a', '#CE5E33', '#1F848B', '#9C29B1'])
      // 1: LEGEND using D3-LEGEND (https://d3-legend.susielu.com/)
      // svg.append("g")
      //   .attr("class", "legend")
      //   .attr("transform", "translate(1000, 200)");
      
      // var legendOrdinal = d3.legendColor()
      //   .shape("path", d3.symbol().type(d3.symbolCircle).size(150)())
      //   .shapePadding(10)
      //   .scale(color)
      
      // svg.select(".legend")
      //   .call(legendOrdinal);
      // svg.selectAll(".legend")
      //     .style("background-color", "white");
      // });

      // 2: LEGEND using manual method
      // create list of keys
      var keysSet = new Set(csv_data.map(d => d.fixed_race))
      var keys = Array.from(keysSet)

      // Add one dot in the legend for each name.
      legendsvg.selectAll('legendDots')
        .data(keys)
        .enter()
        .append("circle")
          .attr("cx", 100)
          .attr("cy", function(d,i){ return i*25}) // 100 is where the first dot appears. 25 is the distance between dots
          .attr("r", 7)
          .style("fill", function(d){ return color(d)})
          .attr("transform", "translate(1000, 200)");

      // Add one dot in the legend for each name.
      legendsvg.selectAll('legendLabels')
        .data(keys)
        .enter()
        .append("text")
          .attr("x", 120)
          .attr("y", function(d,i){ return i*25}) // 100 is where the first dot appears. 25 is the distance between dots
          // .style("fill", function(d){ return color(d)})
          .text(function(d){ return d})
          .attr("text-anchor", "left")
          .style("alignment-baseline", "middle")
          .style("fill", "#b8b8b8")
          .style("font-family", "Didact Gothic")
          .style("text-transform", "lowercase")
          .attr("transform", "translate(1000, 200)");  

      var data = getData(1927, 2019);
      update(data, csv_data);

      var node = graphsvg.selectAll(".graph-circle")

      var winnerData = data.filter(d => d.winner === "TRUE");
      var simulationCircle = d3.forceSimulation()
        .force("center", d3.forceCenter().x(width / 2).y(height / 2)) // Attraction to the center of the svg area
        .force("charge", d3.forceManyBody().strength(0)) // Nodes are attracted one each other of value is > 0
        .force("collide", d3.forceCollide().strength(0.2).radius(6).iterations(1)) // Force that avoids circle overlapping

      simulationCircle
        .nodes(winnerData)
        .on("tick", function(d){
          node
              .attr("cx", function(d){ return d.x; })
              .attr("cy", function(d){ return d.y; })
        });

      var nomineeData = data.filter(d => d.winner === "FALSE");
      var simulationRing = d3.forceSimulation()
        .force("center", d3.forceCenter().x(width / 2).y(height / 2)) // Attraction to the center of the svg area
        .force("charge", d3.forceManyBody().strength(0)) // Nodes are attracted one each other of value is > 0
        .force("collide", d3.forceCollide().strength(0.2).radius(6).iterations(1)) // Force that avoids circle overlapping

      simulationRing
        .nodes(nomineeData)
        .on("tick", function(d){
          node
              .attr("cx", function(d){ return d.x; })
              .attr("cy", function(d){ return d.y; })
        });
    
      // SLIDER LOGIC
      var slider = createD3RangeSlider(1927, 2019, "#slider-container");

      slider.onChange(function(newRange){
        d3.select("#range-label").text(newRange.begin + " - " + newRange.end);
        var newData = getData(newRange.begin, newRange.end);

        update(newData, csv_data)
        
        var numWinners = newData.filter(d => d.winner == "TRUE").length
        simulationCircle.alpha(0.1).alphaTarget(0).restart()
        simulationRing.alpha(0.1).alphaTarget(0).restart()
      });

      slider.range(1927, 2019);


  });
  </script>
</body>