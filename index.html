<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <script src="https://d3js.org/d3.v5.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.13.0/d3-legend.js"></script>
  <script src="https://cdn.rawgit.com/RasmusFonseca/d3RangeSlider/master/d3RangeSlider.js"></script>
  <link href='https://fonts.googleapis.com/css?family=Didact Gothic' rel='stylesheet'>
  <link href="https://cdn.rawgit.com/RasmusFonseca/d3RangeSlider/master/d3RangeSlider.css" rel="stylesheet">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <style type="text/css">
    h1 { 
      color: 	#b8a22a; 
      font-family: 'Didact Gothic', sans-serif; 
      font-size: 60px;
      line-height: 1; 
      margin-left: 40px;
      margin-top: 20px;
      margin-bottom: 0px;
      text-align: left; 
    }

    h2 {
      color: 	#b8a22a; 
      font-family: 'Didact Gothic', sans-serif;
      line-height: 1; 
      margin-top: 5px;
      margin-left: 40px;
      text-align: left; 
    }
    body {
      background-color: rgb(29, 28, 28);
    }

    g.cell {
      background-color: blue;
    }

    #main {
      display: flex;
      width: 1500px;
      margin: auto;
    }

    #slider-section {
      width: 1000px;
      margin: auto;
      padding-top: 30px;
    }

    #slider-container {
      position: relative;
      height:30px;
    }

    .slider {
      background-color: #b8a22a !important;
    }

    .handle {
      height: 12px !important;
      width: 12px !important;
      border-color: black !important;
      background-color: black !important;
      border-radius: 10px;
    }

    #range-label {
      color: white;
      text-align: center;
      font-family: 'Didact Gothic', sans-serif;
      font-size: 30px;
    }

    #graph {
      /* so the graph doesn't go outside of the container on zoom */
      overflow: hidden;
      padding-top: 30px;
    }

    #legend {
      /* z-index for now so that the tooltips work on the graph. need to fix this later. */
      z-index: -100; 
    }

  </style>
</head>
<body>
  <div id="header" style="display: flex; flex-direction: row; align-items: center; margin-left: 50px;">
    <img src="./oscars_icon.png" width="100" height="130">
    <div style="display: flex; flex-direction: column;">
      <h1 id="title">OSCARS</h1>
      <h2>winners & nominees by race</h2>
    </div>
  </div>
  <!-- slider -->
  <div id="slider-section">
    <div id="range-label">1928 - 2019</div>
    <div id="slider-container"></div>
  </div>
  <!-- category selection -->
  <div class="text-center pt-3">
    <button type="button" id="all-btn" class="mx-1 btn btn-light">All</button>
    <button type="button" name="DIRECTING" id="director-btn" class="mx-1 btn btn-outline-light">Best Director</button>
    <button type="button" name="ACTOR IN A LEADING ROLE" id="actor-btn" class="mx-1 btn btn-outline-light">Best Actor</button>
    <button type="button" name="ACTRESS IN A LEADING ROLE" id="actress-btn" class="mx-1 btn btn-outline-light">Best Actress</button>
    <button type="button" name="ACTOR IN A SUPPORTING ROLE" id="sup-actor-btn" class="mx-1 btn btn-outline-light">Best Supporting Actor</button>
    <button type="button" name="ACTRESS IN A SUPPORTING ROLE" id="sup-actress-btn" class="mx-1 btn btn-outline-light">Best Supporting Actress</button>
  </div>
  <!-- graph -->
  <div id="main">
    <div id="graph"></div>
    <div id="legend"></div>
  </div>

  <div id="footer">
    Adapted from: https://www.d3-graph-gallery.com/graph/circularpacking_basic.html, 4/3/2021
  </div>

  <!-- JAVASCRIPT -->
  <script>
    var actorCategory = "ACTOR IN A LEADING ROLE"
    var actressCategory = "ACTRESS IN A LEADING ROLE"
    var actorSupCategory = "ACTOR IN A SUPPORTING ROLE"
    var actressSupCategory = "ACTRESS IN A SUPPORTING ROLE"
    var directorCategory = "DIRECTING"
    var svgWidth = 1000
    var svgHeight = 1000
    var legendWidth = 400
    var width = 1000
    var height = 1000
    var graphsvg = d3.select("#graph")
        .append("svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight)
        // .attr("transform", "translate(400, 0)")  // pushes viz to right + up
        .call(d3.zoom().on("zoom", function () {
          graphsvg.attr("transform", d3.event.transform)
        }))
        .append("g");


    var legendsvg = d3.select("#legend")
      .append("svg")
        .attr("width", legendWidth)
        .attr("height", svgHeight)
        .attr("transform", "translate(0, 200)"); // pushes viz to right + up
    legendsvg.append("g");

    var tooltip = d3.select("#main")
      .append("div")
      .style("position", "absolute")
      .style("visibility", "hidden")
      .style("background-color", "black")
      .style("color", "white")
    
    function update(data, startYear, endYear, categories) {  
      // first, filter data to year range
      let filteredData = data.filter(d => d.year_ceremony >= startYear && d.year_ceremony <= endYear && categories.includes(d.category))
      var winnerDataByCategory = categories.reduce(function(map, category) {
        map[category] = filteredData.filter(d => d.category == category && d.winner == "TRUE");
        return map;
      }, {})

      var nomineeDataByCategory = categories.reduce(function(map, category) {
        map[category] = filteredData.filter(d => d.category == category && d.winner == "FALSE");
        return map;
      }, {})

      var winnerData = filteredData.filter(d => d.winner === "TRUE" && d.year_ceremony >= startYear && d.year_ceremony <= endYear);
      var numWinners = winnerData.length;

      // CALCULATE POSITION OF DOTS

      // we position the nominees in a 1 layer ring, and the physics
      // simulation will take care of repelling the overlaps
      let nomineeRadius = Math.max(Math.sqrt(numWinners*300), 120)
      let winnerRadius = Math.max(numWinners * 0.5, 45)

      // separate sectors by 36 degrees
      var sectorSeparation = 2 * Math.PI / 10.0;
      // the arc angle of each sector
      let arcAngle = (2 * Math.PI - categories.length * sectorSeparation) / categories.length
      if (categories.length == 1) {
        arcAngle = 2 * Math.PI
      }

      var nomineeCounter = categories.reduce(function(map, category) {
        map[category] = 0;
        return map;
      }, {})

      var winnerCounter = categories.reduce(function(map, category) {
        map[category] = 0;
        return map;
      }, {})

      for (let i = 0; i < data.length; i++) {
        if (data[i].year_ceremony < startYear || data[i].year_ceremony > endYear || !categories.includes(data[i].category)) {
          continue
        }

        // if we're looking at a nominee
        if (data[i].winner === "FALSE") {
          // calculate angle of the dot
          var theta = (sectorSeparation + arcAngle) * categories.indexOf(data[i].category) + arcAngle * (nomineeCounter[data[i].category] / nomineeDataByCategory[data[i].category].length)
          data[i].x = nomineeRadius * Math.cos(theta) + width / 2;
          data[i].y = nomineeRadius * Math.sin(theta) + height / 2;
          data[i].level = "Nominee"
          nomineeCounter[data[i].category] += 1
        } else {
          var theta = (sectorSeparation + arcAngle) * categories.indexOf(data[i].category) + arcAngle * (winnerCounter[data[i].category] / winnerDataByCategory[data[i].category].length)
          data[i].x = winnerRadius * Math.cos(theta) + width / 2;
          data[i].y = winnerRadius * Math.sin(theta) + height / 2;
          data[i].level = "Winner"
          winnerCounter[data[i].category] += 1
        }
      }
      
      // default color scale
      // color = d3.scaleOrdinal(d3.schemeCategory10).domain(data.map(d => d.fixed_race));
      // customized color scale
      color = d3.scaleOrdinal()
        .domain(['white', 'black', 'hispanic', 'asian', 'other'])
        .range(['#615516', '#b8a22a', '#CE5E33', '#1F848B', '#9C29B1'])
      var node = graphsvg
        .selectAll(".graph-circle")
        .data(data, d => d.id);
      node.join(
        enter => enter.append("circle")
          .classed("graph-circle", true)
          .attr("r", 2)
          .attr("cx", width / 2)
          .attr("cy", height / 2)
          .style("fill", d => color(d.fixed_race))
          .style("fill-opacity", 1)
          .attr("stroke", d => color(d.fixed_race))
          .style("stroke-width", 4)
          .on("mouseover", function(){
              tooltip
              .style("visibility", "visible")
              })
          .on("mousemove", function(d){
              tooltip
              .style("top", (d3.event.pageY + 5) + "px")
              .style("left", (d3.event.pageX + 5) + "px")
              .html(d.level + "<br>" + "Name: " + d.name + "<br>Film: " + d.film + "<br>Award: " + d.category + "<br>Race: " + d.fixed_race + "<br>Year:" + d.year_ceremony)
              })
          .on("mouseout", function(){
              tooltip
              .style("visibility", "hidden")
              }),
        update => update.attr("r", d => {
            // if the datapoint is within range, it has a radius of 2. otherwise, we hide it with radius 0
            if (d.year_ceremony >= startYear && d.year_ceremony <= endYear && categories.includes(d.category)) {
              return 2
            }
            return 0
          }),
        exit => exit.remove()
      )   
    }

    d3.csv("oscar_nominees_with_fixed_race.csv").then((csv_data) => {
      function getData(startYear, endYear) {
        var data = []
        for (var i = 0; i < csv_data.length; i++) {
          // push all datapoints, both nominees and winners
          var year = csv_data[i].year_ceremony;
          if (year >= startYear && year <= endYear) {
            data.push(csv_data[i]);
          }
        }
        return data;
      }

      // default color scale
      // color = d3.scaleOrdinal(d3.schemeCategory10).domain(data.map(d => d.fixed_race));
      // customized color scale
      color = d3.scaleOrdinal()
        .domain(['white', 'black', 'hispanic', 'asian', 'other'])
        .range(['#615516', '#b8a22a', '#CE5E33', '#1F848B', '#9C29B1'])
      // 1: LEGEND using D3-LEGEND (https://d3-legend.susielu.com/)
      // svg.append("g")
      //   .attr("class", "legend")
      //   .attr("transform", "translate(1000, 200)");
      
      // var legendOrdinal = d3.legendColor()
      //   .shape("path", d3.symbol().type(d3.symbolCircle).size(150)())
      //   .shapePadding(10)
      //   .scale(color)
      
      // svg.select(".legend")
      //   .call(legendOrdinal);
      // svg.selectAll(".legend")
      //     .style("background-color", "white");
      // });

      // 2: LEGEND using manual method
      // create list of keys
      var keysSet = new Set(csv_data.map(d => d.fixed_race))
      var keys = Array.from(keysSet)

      // Add one dot in the legend for each name.
      legendsvg.selectAll('legendDots')
        .data(keys)
        .enter()
        .append("circle")
          .attr("cx", 100)
          .attr("cy", function(d,i){ return (i+1)*25}) // 100 is where the first dot appears. 25 is the distance between dots
          .attr("r", 7)
          .style("fill", function(d){ return color(d)})

      // Add one dot in the legend for each name.
      legendsvg.selectAll('legendLabels')
        .data(keys)
        .enter()
        .append("text")
          .attr("x", 120)
          .attr("y", function(d,i){ return (i+1)*25}) // 100 is where the first dot appears. 25 is the distance between dots
          // .style("fill", function(d){ return color(d)})
          .text(function(d){ return d})
          .attr("text-anchor", "left")
          .style("alignment-baseline", "middle")
          .style("fill", "#b8b8b8")
          .style("font-family", "Didact Gothic")
          .style("text-transform", "lowercase");

      let categories = [actorCategory, actressCategory, actorSupCategory, actressSupCategory, directorCategory]
      update(csv_data, 1928, 2019, categories);

      var node = graphsvg.selectAll(".graph-circle")

      var winnerData = csv_data.filter(d => d.winner === "TRUE");
      var simulationCircle = d3.forceSimulation()
        .force("center", d3.forceCenter().x(width / 2).y(height / 2)) // Attraction to the center of the svg area
        .force("charge", d3.forceManyBody().strength(0)) // Nodes are attracted one each other of value is > 0
        .force("collide", d3.forceCollide().strength(0.2).radius(6).iterations(1)) // Force that avoids circle overlapping

      simulationCircle
        .nodes(winnerData)
        .on("tick", function(d){
          node
              .attr("cx", function(d){ return d.x; })
              .attr("cy", function(d){ return d.y; })
        });

      var nomineeData = csv_data.filter(d => d.winner === "FALSE");
      var simulationRing = d3.forceSimulation()
        .force("center", d3.forceCenter().x(width / 2).y(height / 2)) // Attraction to the center of the svg area
        .force("charge", d3.forceManyBody().strength(0)) // Nodes are attracted one each other of value is > 0
        .force("collide", d3.forceCollide().strength(0.2).radius(6).iterations(1)) // Force that avoids circle overlapping

      simulationRing
        .nodes(nomineeData)
        .on("tick", function(d){
          node
              .attr("cx", function(d){ return d.x; })
              .attr("cy", function(d){ return d.y; })
        });
    
      // SLIDER LOGIC
      var slider = createD3RangeSlider(1928, 2019, "#slider-container");

      slider.onChange(function(newRange){
        d3.select("#range-label").text(newRange.begin + " - " + newRange.end);
        var newData = getData(newRange.begin, newRange.end);

        update(csv_data, newRange.begin, newRange.end, categories)
        
        var winners = newData.filter(d => d.winner == "TRUE");
        var nominees = newData.filter(d => d.winner == "FALSE")
        simulationCircle.nodes(winners).alpha(0.1).alphaTarget(0).restart()
        simulationRing.nodes(nominees).alpha(0.1).alphaTarget(0).restart()
      });

      slider.range(1928, 2019);

      // // CATEGORY BUTTON LOGIC
      function handleCategoryChange(category) {
        return function(e){
          // if all categories selected, then select only the "All" button
          if (category == "all") {
            // Outline all buttons except for the "All" button
            var els = document.getElementsByClassName("btn")
            for (el of els){
              el.classList.remove('btn-light');
              el.classList.add('btn-outline-light');
            }
            // fill the All button
            document.getElementById("all-btn").classList.remove('btn-outline-light');
            document.getElementById("all-btn").classList.add('btn-light');
            categories = [actorCategory, actressCategory, actorSupCategory, actressSupCategory, directorCategory]
          } else if (categories.includes(category)) {
            if (categories.length == 5) { // if all categories were previously selected, then just select the single category
              document.getElementById("all-btn").classList.remove('btn-light')
              document.getElementById("all-btn").classList.add('btn-outline-light')
              document.getElementsByName(category)[0].classList.remove('btn-outline-light')
              document.getElementsByName(category)[0].classList.add('btn-light')
              categories = [category]
            } else { // the category was already selected, so remove it
              document.getElementsByName(category)[0].classList.remove('btn-light')
              document.getElementsByName(category)[0].classList.add('btn-outline-light')
              var index = categories.indexOf(category);
              categories.splice(index, 1);
            }
          } else { // the category is not yet selected, so select it.
            if (categories.length == 4) { // this is the only category not yet selected. now that it is, select "All"
              var els = document.getElementsByClassName("btn")
              for (el of els){
                el.classList.remove('btn-light');
                el.classList.add('btn-outline-light');
              }
              document.getElementById("all-btn").classList.remove('btn-outline-light');
              document.getElementById("all-btn").classList.add('btn-light');
            } else {
              var el = document.getElementsByName(category)[0]
              el.classList.add('btn-light')
              el.classList.remove('btn-outline-light')
            }
            categories.push(category)
            // then, sort alphabetically so the graph is consistent in ordering
            categories = categories.sort()
          }
          update(csv_data, slider.range().begin, slider.range().end, categories)
          var newData = getData(slider.range().begin, slider.range().end).filter(d => categories.includes(d.category))
          var winners = newData.filter(d => d.winner == "TRUE");
          var nominees = newData.filter(d => d.winner == "FALSE")
          simulationCircle.nodes(winners).alpha(0.1).alphaTarget(0).restart()
          simulationRing.nodes(nominees).alpha(0.1).alphaTarget(0).restart()
        }
      }
      document.getElementById("all-btn").addEventListener("click", handleCategoryChange("all"))
      document.getElementById("actor-btn").addEventListener("click", handleCategoryChange(actorCategory))
      document.getElementById("actress-btn").addEventListener("click", handleCategoryChange(actressCategory))
      document.getElementById("sup-actor-btn").addEventListener("click", handleCategoryChange(actorSupCategory))
      document.getElementById("sup-actress-btn").addEventListener("click", handleCategoryChange(actressSupCategory))
      document.getElementById("director-btn").addEventListener("click", handleCategoryChange(directorCategory))
    });
  </script>
</body>